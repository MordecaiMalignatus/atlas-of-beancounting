* Path of Beancounting

Ever been curious about what the numbers we all like so much actually look like
behind your mapping? Cool, me too.

* Things to be done
** TODO Data storage subsystem
*** TODO Pull in SQLite for data storage (Rusqlite?)
https://github.com/jgallagher/rusqlite

Yup, Rusqlite.
*** DONE Find way to bundle Sqlite
CLOSED: [2018-11-15 Thu 05:24]
Rusqlite has a ~bundled~ feature flag that directly embeds a binary of SQLite
for situations like windows. _fuck yessss_
*** TODO Design data scheme for storage.
** TODO Mastermind
The mastermind is the centre of the calculations. It consumes event logs, drops,
writes to the database and sends events to the frontend.

It maintains a state machine that makes it possible to sort events to maps, so
deaths can be mitigated. (A map entry to the same map after a death is taken to
be the same map, unless a new one is explicitly triggered)
** TODO Pricing
*** TODO Find way to grab and cache the poe.ninja prices
**** TODO Document the inofficial API via browser dev tools in POE.ninja.
- Currency Overview: ~https://poe.ninja/api/currencyoverview?league=$LEAGUE&type=Currency&date=$DATE~
**** TODO Write/use an expiring cache for the prices to make sure not to spam the poe.ninja API.
I think this can be just reduced down to a simple hashmap, with some sort of
centrally-stored creation date. Ideally stored *in* the hashmap, but that might
ruin my polymorphism.

I think the cache is going to be kept in the central actor anyways, so I might
have both available via the recursion struct/state.
**** TODO Persist the cache to disk to avoid re-querying on boot.
**** TODO Provide hook to invalidate the cache.
** TODO Meta
*** TODO Translate this document to GH issues.
** TODO Front-end
*** TODO Build compile script
This would need to inline everything into the ~index.html~ file, and build that
before cargo builds the main thing, to then get inlined.

Boscop, the author of web-view, posted this:
https://www.npmjs.com/package/inline-assets
which looks like what I want to inline everything. Just need to write a build
pipe.
*** TODO Send test events to the front-end to see if it all works out.
*** TODO Make sure the frontend integrates well into the desktop world.
- C-w should close the window but leave the daemon running (systray)
- C-q should quit everything,
- C-, should open options,
** TODO Log Parser
*** TODO Make copy of my event log on desktop and use it for testing.
*** TODO Expand Message Enum with events found in the logs.
** TODO User Input
*** TODO Look into Input Bot
https://github.com/obv-mikhail/InputBot

This will probably add another thread that has to be handled to the picture, for
hotkeys and "start new map" things.
*** TODO Handle "new maps"
I need a hotkey that, when mousing over a map, copies that map to the clipboard
(thus triggering parsing) and uses that as the new current map to which drops
will be logged.
* About the Project

** Why is this being written?
I don't like uploading data like that to a centralised service for no good
reason, so here's something that works entirely machine-local, doesn't snoop for
anything, and doesn't consume too many resources.
